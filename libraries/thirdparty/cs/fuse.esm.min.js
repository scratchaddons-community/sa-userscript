function t(t){return Array.isArray?Array.isArray(t):"[object Array]"===o(t)}function e(t){return"string"==typeof t}function i(t){return"number"==typeof t}function n(t){return 1==t||0==t||function(t){return s(t)&&null!==t}(t)&&"[object Boolean]"==o(t)}function s(t){return"object"==typeof t}function r(t){return null!=t}function c(t){return!t.trim().length}function o(t){return null==t?void 0===t?"[object Undefined]":"[object Null]":{}.toString.call(t)}function h(i){let n=null,s=null,r=null,c=1,o=null
if(e(i)||t(i))r=i,n=a(i),s=u(i)
else{if(!L.call(i,"name"))throw new Error("Missing name property in key")
const t=i.name
if(r=t,L.call(i,"weight")&&(c=i.weight,0>=c))throw new Error((t=>`Property 'weight' in key '${t}' must be a positive integer`)(t))
n=a(t),s=u(t),o=i.getFn}return{path:n,id:s,weight:c,src:r,getFn:o}}function a(e){return t(e)?e:e.split(".")}function u(e){return t(e)?e.join("."):e}function l(t,e,{getFn:i=S.getFn,fieldNormWeight:n=S.fieldNormWeight}={}){const s=new A({getFn:i,fieldNormWeight:n})
return s.setKeys(t.map(h)),s.setSources(e),s.create(),s}function d(t,{errors:e=0,currentLocation:i=0,expectedLocation:n=0,distance:s=S.distance,ignoreLocation:r=S.ignoreLocation}={}){const c=e/t.length
if(r)return c
const o=Math.abs(n-i)
return s?c+o/s:o?1:c}function f(t,e,i,{location:n=S.location,distance:s=S.distance,threshold:r=S.threshold,findAllMatches:c=S.findAllMatches,minMatchCharLength:o=S.minMatchCharLength,includeMatches:h=S.includeMatches,ignoreLocation:a=S.ignoreLocation}={}){if(e.length>32)throw new Error("Pattern length exceeds max of 32.")
const u=e.length,l=t.length,f=Math.max(0,Math.min(n,l))
let g=r,M=f
const x=o>1||h,m=x?Array(l):[]
let p
for(;(p=t.indexOf(e,M))>-1;){let t=d(e,{currentLocation:p,expectedLocation:f,distance:s,ignoreLocation:a})
if(g=Math.min(t,g),M=p+u,x){let t=0
for(;u>t;)m[p+t]=1,t+=1}}M=-1
let y=[],L=1,v=u+l
const w=1<<u-1
for(let n=0;u>n;n+=1){let r=0,o=v
for(;o>r;)d(e,{errors:n,currentLocation:f+o,expectedLocation:f,distance:s,ignoreLocation:a})>g?v=o:r=o,o=Math.floor((v-r)/2+r)
v=o
let h=Math.max(1,f-o+1),p=c?l:Math.min(f+o,l)+u,S=Array(p+2)
S[p+1]=(1<<n)-1
for(let r=p;r>=h;r-=1){let c=r-1,o=i[t.charAt(c)]
if(x&&(m[c]=+!!o),S[r]=(S[r+1]<<1|1)&o,n&&(S[r]|=(y[r+1]|y[r])<<1|1|y[r+1]),S[r]&w&&(L=d(e,{errors:n,currentLocation:c,expectedLocation:f,distance:s,ignoreLocation:a}),g>=L)){if(g=L,M=c,f>=M)break
h=Math.max(1,2*f-M)}}if(d(e,{errors:n+1,currentLocation:f,expectedLocation:f,distance:s,ignoreLocation:a})>g)break
y=S}const A={isMatch:M>=0,score:Math.max(.001,L)}
if(x){const t=function(t=[],e=S.minMatchCharLength){let i=[],n=-1,s=-1,r=0
for(let c=t.length;c>r;r+=1){let c=t[r]
c&&-1===n?n=r:c||-1===n||(s=r-1,s-n+1>=e&&i.push([n,s]),n=-1)}return t[r-1]&&r-n>=e&&i.push([n,r-1]),i}(m,o)
t.length?h&&(A.indices=t):A.isMatch=0}return A}function g(t){let e={}
for(let i=0,n=t.length;n>i;i+=1){const s=t.charAt(i)
e[s]=(e[s]||0)|1<<n-i-1}return e}function M(t,e){const i=t.match(e)
return i?i[1]:null}function x(t,e){for(let i=0,n=j.length;n>i;i+=1){let n=j[i]
if(n.condition(t,e))return new n(t,e)}return new k(t,e)}function m(i,n,{auto:r=1}={}){const c=i=>{let o=Object.keys(i)
const h=(t=>!!t[W])(i)
if(!h&&o.length>1&&!E(i))return c(_(i))
if((e=>!t(e)&&s(e)&&!E(e))(i)){const t=h?i[W]:o[0],s=h?i.$val:i[t]
if(!e(s))throw new Error((t=>`Invalid value for key ${t}`)(t))
const c={keyId:u(t),pattern:s}
return r&&(c.searcher=x(s,n)),c}let a={children:[],operator:o[0]}
return o.forEach((e=>{const n=i[e]
t(n)&&n.forEach((t=>{a.children.push(c(t))}))})),a}
return E(i)||(i=_(i)),c(i)}function p(t,e){const i=t.matches
e.matches=[],r(i)&&i.forEach((t=>{if(!r(t.indices)||!t.indices.length)return
const{indices:i,value:n}=t
let s={indices:i,value:n}
t.key&&(s.key=t.key.src),t.idx>-1&&(s.refIndex=t.idx),e.matches.push(s)}))}function y(t,e){e.score=t.score}const L={}.hasOwnProperty
class v{constructor(t){this._keys=[],this._keyMap={}
let e=0
t.forEach((t=>{let i=h(t)
e+=i.weight,this._keys.push(i),this._keyMap[i.id]=i,e+=i.weight})),this._keys.forEach((t=>{t.weight/=e}))}get(t){return this._keyMap[t]}keys(){return this._keys}toJSON(){return JSON.stringify(this._keys)}}var S={isCaseSensitive:0,includeScore:0,keys:[],shouldSort:1,sortFn(t,e){return t.score===e.score?e.idx>t.idx?-1:1:e.score>t.score?-1:1},includeMatches:0,findAllMatches:0,minMatchCharLength:1,location:0,threshold:.6,distance:100,...{useExtendedSearch:0,getFn(s,c){let o=[],h=0
const a=(s,c,u)=>{if(r(s))if(c[u]){const l=s[c[u]]
if(!r(l))return
if(u===c.length-1&&(e(l)||i(l)||n(l)))o.push(function(t){return null==t?"":function(t){if("string"==typeof t)return t
let e=t+""
return"0"==e&&1/t==-1/0?"-0":e}(t)}(l))
else if(t(l)){h=1
for(let t=0,e=l.length;e>t;t+=1)a(l[t],c,u+1)}else c.length&&a(l,c,u+1)}else o.push(s)}
return a(s,e(c)?c.split("."):c,0),h?o:o[0]},ignoreLocation:0,ignoreFieldNorm:0,fieldNormWeight:1}}
const w=/[^ ]+/g
class A{constructor({getFn:t=S.getFn,fieldNormWeight:e=S.fieldNormWeight}={}){this.norm=function(t=1,e=3){const i=new Map,n=Math.pow(10,e)
return{get(e){const s=e.match(w).length
if(i.has(s))return i.get(s)
const r=1/Math.pow(s,.5*t),c=parseFloat(Math.round(r*n)/n)
return i.set(s,c),c},clear(){i.clear()}}}(e,3),this.getFn=t,this.isCreated=0,this.setIndexRecords()}setSources(t=[]){this.docs=t}setIndexRecords(t=[]){this.records=t}setKeys(t=[]){this.keys=t,this._keysMap={},t.forEach(((t,e)=>{this._keysMap[t.id]=e}))}create(){!this.isCreated&&this.docs.length&&(this.isCreated=1,e(this.docs[0])?this.docs.forEach(((t,e)=>{this._addString(t,e)})):this.docs.forEach(((t,e)=>{this._addObject(t,e)})),this.norm.clear())}add(t){const i=this.size()
e(t)?this._addString(t,i):this._addObject(t,i)}removeAt(t){this.records.splice(t,1)
for(let e=t,i=this.size();i>e;e+=1)this.records[e].i-=1}getValueForItemAtKeyId(t,e){return t[this._keysMap[e]]}size(){return this.records.length}_addString(t,e){if(!r(t)||c(t))return
let i={v:t,i:e,n:this.norm.get(t)}
this.records.push(i)}_addObject(i,n){let s={i:n,$:{}}
this.keys.forEach(((n,o)=>{let h=n.getFn?n.getFn(i):this.getFn(i,n.path)
if(r(h))if(t(h)){let i=[]
const n=[{nestedArrIndex:-1,value:h}]
for(;n.length;){const{nestedArrIndex:s,value:o}=n.pop()
if(r(o))if(e(o)&&!c(o)){let t={v:o,i:s,n:this.norm.get(o)}
i.push(t)}else t(o)&&o.forEach(((t,e)=>{n.push({nestedArrIndex:e,value:t})}))}s.$[o]=i}else if(e(h)&&!c(h)){let t={v:h,n:this.norm.get(h)}
s.$[o]=t}})),this.records.push(s)}toJSON(){return{keys:this.keys,records:this.records}}}class k{constructor(t,{location:e=S.location,threshold:i=S.threshold,distance:n=S.distance,includeMatches:s=S.includeMatches,findAllMatches:r=S.findAllMatches,minMatchCharLength:c=S.minMatchCharLength,isCaseSensitive:o=S.isCaseSensitive,ignoreLocation:h=S.ignoreLocation}={}){if(this.options={location:e,threshold:i,distance:n,includeMatches:s,findAllMatches:r,minMatchCharLength:c,isCaseSensitive:o,ignoreLocation:h},this.pattern=o?t:t.toLowerCase(),this.chunks=[],!this.pattern.length)return
const a=(t,e)=>{this.chunks.push({pattern:t,alphabet:g(t),startIndex:e})},u=this.pattern.length
if(u>32){let t=0
const e=u%32,i=u-e
for(;i>t;)a(this.pattern.substr(t,32),t),t+=32
if(e){const t=u-32
a(this.pattern.substr(t),t)}}else a(this.pattern,0)}searchIn(t){const{isCaseSensitive:e,includeMatches:i}=this.options
if(e||(t=t.toLowerCase()),this.pattern===t){let e={isMatch:1,score:0}
return i&&(e.indices=[[0,t.length-1]]),e}const{location:n,distance:s,threshold:r,findAllMatches:c,minMatchCharLength:o,ignoreLocation:h}=this.options
let a=[],u=0,l=0
this.chunks.forEach((({pattern:e,alphabet:d,startIndex:g})=>{const{isMatch:M,score:x,indices:m}=f(t,e,d,{location:n+g,distance:s,threshold:r,findAllMatches:c,minMatchCharLength:o,includeMatches:i,ignoreLocation:h})
M&&(l=1),u+=x,M&&m&&(a=[...a,...m])}))
let d={isMatch:l,score:l?u/this.chunks.length:1}
return l&&i&&(d.indices=a),d}}class C{constructor(t){this.pattern=t}static isMultiMatch(t){return M(t,this.multiRegex)}static isSingleMatch(t){return M(t,this.singleRegex)}search(){}}class b extends C{constructor(t,{location:e=S.location,threshold:i=S.threshold,distance:n=S.distance,includeMatches:s=S.includeMatches,findAllMatches:r=S.findAllMatches,minMatchCharLength:c=S.minMatchCharLength,isCaseSensitive:o=S.isCaseSensitive,ignoreLocation:h=S.ignoreLocation}={}){super(t),this._bitapSearch=new k(t,{location:e,threshold:i,distance:n,includeMatches:s,findAllMatches:r,minMatchCharLength:c,isCaseSensitive:o,ignoreLocation:h})}static get type(){return"fuzzy"}static get multiRegex(){return/^"(.*)"$/}static get singleRegex(){return/^(.*)$/}search(t){return this._bitapSearch.searchIn(t)}}class R extends C{constructor(t){super(t)}static get type(){return"include"}static get multiRegex(){return/^'"(.*)"$/}static get singleRegex(){return/^'(.*)$/}search(t){let e,i=0
const n=[],s=this.pattern.length
for(;(e=t.indexOf(this.pattern,i))>-1;)i=e+s,n.push([e,i-1])
const r=!!n.length
return{isMatch:r,score:r?0:1,indices:n}}}const F=[class extends C{constructor(t){super(t)}static get type(){return"exact"}static get multiRegex(){return/^="(.*)"$/}static get singleRegex(){return/^=(.*)$/}search(t){const e=t===this.pattern
return{isMatch:e,score:e?0:1,indices:[0,this.pattern.length-1]}}},R,class extends C{constructor(t){super(t)}static get type(){return"prefix-exact"}static get multiRegex(){return/^\^"(.*)"$/}static get singleRegex(){return/^\^(.*)$/}search(t){const e=t.startsWith(this.pattern)
return{isMatch:e,score:e?0:1,indices:[0,this.pattern.length-1]}}},class extends C{constructor(t){super(t)}static get type(){return"inverse-prefix-exact"}static get multiRegex(){return/^!\^"(.*)"$/}static get singleRegex(){return/^!\^(.*)$/}search(t){const e=!t.startsWith(this.pattern)
return{isMatch:e,score:e?0:1,indices:[0,t.length-1]}}},class extends C{constructor(t){super(t)}static get type(){return"inverse-suffix-exact"}static get multiRegex(){return/^!"(.*)"\$$/}static get singleRegex(){return/^!(.*)\$$/}search(t){const e=!t.endsWith(this.pattern)
return{isMatch:e,score:e?0:1,indices:[0,t.length-1]}}},class extends C{constructor(t){super(t)}static get type(){return"suffix-exact"}static get multiRegex(){return/^"(.*)"\$$/}static get singleRegex(){return/^(.*)\$$/}search(t){const e=t.endsWith(this.pattern)
return{isMatch:e,score:e?0:1,indices:[t.length-this.pattern.length,t.length-1]}}},class extends C{constructor(t){super(t)}static get type(){return"inverse-exact"}static get multiRegex(){return/^!"(.*)"$/}static get singleRegex(){return/^!(.*)$/}search(t){const e=-1===t.indexOf(this.pattern)
return{isMatch:e,score:e?0:1,indices:[0,t.length-1]}}},b],I=F.length,N=/ +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,$=new Set([b.type,R.type]),j=[],O="$and",W="$path",E=t=>!(!t[O]&&!t.$or),_=t=>({[O]:Object.keys(t).map((e=>({[e]:t[e]})))})
class z{constructor(t,e={},i){this.options={...S,...e},this._keyStore=new v(this.options.keys),this.setCollection(t,i)}setCollection(t,e){if(this._docs=t,e&&!(e instanceof A))throw new Error("Incorrect 'index' type")
this._myIndex=e||l(this.options.keys,this._docs,{getFn:this.options.getFn,fieldNormWeight:this.options.fieldNormWeight})}add(t){r(t)&&(this._docs.push(t),this._myIndex.add(t))}remove(t=(()=>0)){const e=[]
for(let i=0,n=this._docs.length;n>i;i+=1){const s=this._docs[i]
t(s,i)&&(this.removeAt(i),i-=1,n-=1,e.push(s))}return e}removeAt(t){this._docs.splice(t,1),this._myIndex.removeAt(t)}getIndex(){return this._myIndex}search(t,{limit:n=-1}={}){const{includeMatches:s,includeScore:r,shouldSort:c,sortFn:o,ignoreFieldNorm:h}=this.options
let a=e(t)?e(this._docs[0])?this._searchStringList(t):this._searchObjectList(t):this._searchLogical(t)
return function(t,{ignoreFieldNorm:e=S.ignoreFieldNorm}){t.forEach((t=>{let i=1
t.matches.forEach((({key:t,norm:n,score:s})=>{const r=t?t.weight:null
i*=Math.pow(0===s&&r?Number.EPSILON:s,(r||1)*(e?1:n))})),t.score=i}))}(a,{ignoreFieldNorm:h}),c&&a.sort(o),i(n)&&n>-1&&(a=a.slice(0,n)),function(t,e,{includeMatches:i=S.includeMatches,includeScore:n=S.includeScore}={}){const s=[]
return i&&s.push(p),n&&s.push(y),t.map((t=>{const{idx:i}=t,n={item:e[i],refIndex:i}
return s.length&&s.forEach((e=>{e(t,n)})),n}))}(a,this._docs,{includeMatches:s,includeScore:r})}_searchStringList(t){const e=x(t,this.options),{records:i}=this._myIndex,n=[]
return i.forEach((({v:t,i,n:s})=>{if(!r(t))return
const{isMatch:c,score:o,indices:h}=e.searchIn(t)
c&&n.push({item:t,idx:i,matches:[{score:o,value:t,norm:s,indices:h}]})})),n}_searchLogical(t){const e=m(t,this.options),i=(t,e,n)=>{if(!t.children){const{keyId:i,searcher:s}=t,r=this._findMatches({key:this._keyStore.get(i),value:this._myIndex.getValueForItemAtKeyId(e,i),searcher:s})
return r&&r.length?[{idx:n,item:e,matches:r}]:[]}const s=[]
for(let r=0,c=t.children.length;c>r;r+=1){const c=i(t.children[r],e,n)
if(c.length)s.push(...c)
else if(t.operator===O)return[]}return s},n={},s=[]
return this._myIndex.records.forEach((({$:t,i:c})=>{if(r(t)){let r=i(e,t,c)
r.length&&(n[c]||(n[c]={idx:c,item:t,matches:[]},s.push(n[c])),r.forEach((({matches:t})=>{n[c].matches.push(...t)})))}})),s}_searchObjectList(t){const e=x(t,this.options),{keys:i,records:n}=this._myIndex,s=[]
return n.forEach((({$:t,i:n})=>{if(!r(t))return
let c=[]
i.forEach(((i,n)=>{c.push(...this._findMatches({key:i,value:t[n],searcher:e}))})),c.length&&s.push({idx:n,item:t,matches:c})})),s}_findMatches({key:e,value:i,searcher:n}){if(!r(i))return[]
let s=[]
if(t(i))i.forEach((({v:t,i,n:c})=>{if(!r(t))return
const{isMatch:o,score:h,indices:a}=n.searchIn(t)
o&&s.push({score:h,key:e,value:t,idx:i,norm:c,indices:a})}))
else{const{v:t,n:r}=i,{isMatch:c,score:o,indices:h}=n.searchIn(t)
c&&s.push({score:o,key:e,value:t,norm:r,indices:h})}return s}}z.version="6.6.2",z.createIndex=l,z.parseIndex=function(t,{getFn:e=S.getFn,fieldNormWeight:i=S.fieldNormWeight}={}){const{keys:n,records:s}=t,r=new A({getFn:e,fieldNormWeight:i})
return r.setKeys(n),r.setIndexRecords(s),r},z.config=S,j.push(class{constructor(t,{isCaseSensitive:e=S.isCaseSensitive,includeMatches:i=S.includeMatches,minMatchCharLength:n=S.minMatchCharLength,ignoreLocation:s=S.ignoreLocation,findAllMatches:r=S.findAllMatches,location:c=S.location,threshold:o=S.threshold,distance:h=S.distance}={}){this.query=null,this.options={isCaseSensitive:e,includeMatches:i,minMatchCharLength:n,findAllMatches:r,ignoreLocation:s,location:c,threshold:o,distance:h},this.pattern=e?t:t.toLowerCase(),this.query=function(t,e={}){return t.split("|").map((t=>{let i=t.trim().split(N).filter((t=>t&&!!t.trim())),n=[]
for(let t=0,s=i.length;s>t;t+=1){const s=i[t]
let r=0,c=-1
for(;!r&&++c<I;){const t=F[c]
let i=t.isMultiMatch(s)
i&&(n.push(new t(i,e)),r=1)}if(!r)for(c=-1;++c<I;){const t=F[c]
let i=t.isSingleMatch(s)
if(i){n.push(new t(i,e))
break}}}return n}))}(this.pattern,this.options)}static condition(t,e){return e.useExtendedSearch}searchIn(t){const e=this.query
if(!e)return{isMatch:0,score:1}
const{includeMatches:i,isCaseSensitive:n}=this.options
t=n?t:t.toLowerCase()
let s=0,r=[],c=0
for(let n=0,o=e.length;o>n;n+=1){const o=e[n]
r.length=0,s=0
for(let e=0,n=o.length;n>e;e+=1){const n=o[e],{isMatch:h,indices:a,score:u}=n.search(t)
if(!h){c=0,s=0,r.length=0
break}s+=1,c+=u,i&&($.has(n.constructor.type)?r=[...r,...a]:r.push(a))}if(s){let t={isMatch:1,score:c/s}
return i&&(t.indices=r),t}}return{isMatch:0,score:1}}})
export{z as default}
